# Azure DevOps Pipeline for BuildAQ Platform
trigger:
  branches:
    include:
    - main
    - develop
  paths:
    exclude:
    - README.md
    - docs/**

variables:
  # Build variables
  buildConfiguration: 'Release'
  azureSubscription: 'BuildAQ-Production'
  containerRegistry: 'buildaq.azurecr.io'
  imageRepository: 'buildaq'
  dockerfilePath: '$(Build.SourcesDirectory)/Dockerfile'
  tag: '$(Build.BuildId)'
  
  # Kubernetes variables
  kubernetesServiceConnection: 'buildaq-aks-connection'
  k8sNamespace: 'production'
  k8sNamespaceStaging: 'staging'

stages:
- stage: Build
  displayName: Build and Test
  jobs:
  - job: BuildFrontend
    displayName: 'Build Frontend Applications'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '20.x'
      displayName: 'Install Node.js'
    
    - script: |
        npm ci
        npx nx affected:build --prod --parallel --max-parallel=3
      displayName: 'Build affected frontend apps'
    
    - script: |
        npx nx affected:test --parallel --max-parallel=3 --coverage
      displayName: 'Run frontend tests'
    
    - script: |
        npx nx affected:e2e --parallel --max-parallel=2
      displayName: 'Run E2E tests'
      condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/junit.xml'
        testRunTitle: 'Frontend Test Results'
      condition: always()
    
    - task: PublishCodeCoverageResults@1
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(System.DefaultWorkingDirectory)/coverage/*/cobertura-coverage.xml'
      displayName: 'Publish code coverage'

  - job: BuildBackend
    displayName: 'Build Backend APIs'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: UseDotNet@2
      inputs:
        packageType: 'sdk'
        version: '8.0.x'
      displayName: 'Install .NET 8 SDK'
    
    - script: |
        dotnet restore backend/BuildAQ.sln
        dotnet build backend/BuildAQ.sln --configuration $(buildConfiguration) --no-restore
      displayName: 'Build backend services'
    
    - script: |
        dotnet test backend/BuildAQ.sln --configuration $(buildConfiguration) --no-build --logger trx --collect:"XPlat Code Coverage"
      displayName: 'Run backend tests'
    
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '**/*.trx'
        testRunTitle: 'Backend Test Results'
      condition: always()

- stage: Security
  displayName: Security Scans
  dependsOn: Build
  jobs:
  - job: SecurityScan
    displayName: 'Security Analysis'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '20.x'
      displayName: 'Install Node.js'
    
    - script: |
        npm install -g snyk
        snyk auth $(SNYK_TOKEN)
        snyk test --severity-threshold=high
      displayName: 'Snyk Security Scan'
      continueOnError: true
    
    - task: CmdLine@2
      inputs:
        script: |
          docker run --rm -v $(Build.SourcesDirectory):/src -w /src securecodewarrior/docker-image-scanner:latest
      displayName: 'Container Image Security Scan'
      continueOnError: true

- stage: BuildImages
  displayName: Build Docker Images
  dependsOn: Security
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - job: BuildDockerImages
    displayName: 'Build and Push Docker Images'
    pool:
      vmImage: 'ubuntu-latest'
    strategy:
      matrix:
        shell:
          imageName: 'shell'
          dockerFile: '$(Build.SourcesDirectory)/docker/shell/Dockerfile'
        schools:
          imageName: 'schools'
          dockerFile: '$(Build.SourcesDirectory)/docker/schools/Dockerfile'
        hospital:
          imageName: 'hospital'
          dockerFile: '$(Build.SourcesDirectory)/docker/hospital/Dockerfile'
        authapi:
          imageName: 'buildaqapi-auth'
          dockerFile: '$(Build.SourcesDirectory)/docker/backend/auth-api.Dockerfile'
        schoolsapi:
          imageName: 'buildaqapi-schools'
          dockerFile: '$(Build.SourcesDirectory)/docker/backend/schools-api.Dockerfile'
    steps:
    - task: Docker@2
      displayName: 'Login to ACR'
      inputs:
        command: 'login'
        containerRegistry: $(containerRegistry)
    
    - task: Docker@2
      displayName: 'Build and Push $(imageName)'
      inputs:
        command: 'buildAndPush'
        repository: '$(imageName)'
        dockerfile: '$(dockerFile)'
        containerRegistry: $(containerRegistry)
        tags: |
          $(tag)
          latest

- stage: DeployStaging
  displayName: Deploy to Staging
  dependsOn: BuildImages
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: DeployToStaging
    displayName: 'Deploy to Staging Environment'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'staging'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: KubernetesManifest@0
            displayName: 'Deploy to Staging'
            inputs:
              action: 'deploy'
              kubernetesServiceConnection: $(kubernetesServiceConnection)
              namespace: $(k8sNamespaceStaging)
              manifests: |
                $(Pipeline.Workspace)/manifests/staging/deployment.yaml
                $(Pipeline.Workspace)/manifests/staging/service.yaml
                $(Pipeline.Workspace)/manifests/staging/ingress.yaml
              containers: |
                $(containerRegistry)/shell:$(tag)
                $(containerRegistry)/schools:$(tag)
                $(containerRegistry)/buildaqapi-auth:$(tag)

  - job: StagingTests
    displayName: 'Staging Smoke Tests'
    dependsOn: DeployToStaging
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: |
        npm ci
        npx playwright test --config=playwright.staging.config.ts
      displayName: 'Run staging smoke tests'
    
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/test-results.xml'
        testRunTitle: 'Staging Smoke Tests'
      condition: always()

- stage: DeployProduction
  displayName: Deploy to Production
  dependsOn: DeployStaging
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: DeployToProduction
    displayName: 'Deploy to Production Environment'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureCLI@2
            displayName: 'Pre-deployment Health Check'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Check if all required services are healthy
                kubectl get pods -n $(k8sNamespace) --field-selector=status.phase=Running
                
          - task: KubernetesManifest@0
            displayName: 'Deploy to Production'
            inputs:
              action: 'deploy'
              kubernetesServiceConnection: $(kubernetesServiceConnection)
              namespace: $(k8sNamespace)
              manifests: |
                $(Pipeline.Workspace)/manifests/production/deployment.yaml
                $(Pipeline.Workspace)/manifests/production/service.yaml
                $(Pipeline.Workspace)/manifests/production/ingress.yaml
              containers: |
                $(containerRegistry)/shell:$(tag)
                $(containerRegistry)/schools:$(tag)
                $(containerRegistry)/buildaqapi-auth:$(tag)
          
          - task: AzureCLI@2
            displayName: 'Post-deployment Health Check'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Wait for rollout to complete
                kubectl rollout status deployment/buildaq-shell -n $(k8sNamespace)
                kubectl rollout status deployment/buildaq-schools -n $(k8sNamespace)
                kubectl rollout status deployment/buildaq-auth-api -n $(k8sNamespace)
                
                # Run health checks
                kubectl get pods -n $(k8sNamespace) -o wide
                
                # Test endpoints
                curl -f https://buildaq.com/health || exit 1
                curl -f https://schools.buildaq.com/health || exit 1
                curl -f https://api.buildaq.com/health || exit 1

  - job: ProductionTests
    displayName: 'Production Health Tests'
    dependsOn: DeployToProduction
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: |
        npm ci
        npx playwright test --config=playwright.production.config.ts
      displayName: 'Run production health tests'
    
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/test-results.xml'
        testRunTitle: 'Production Health Tests'
      condition: always()

- stage: Performance
  displayName: Performance Testing
  dependsOn: DeployProduction
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - job: LoadTest
    displayName: 'Load Testing'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: |
        npm install -g artillery
        artillery run performance/load-test.yml
      displayName: 'Run load tests'
    
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/artillery-report.xml'
        testRunTitle: 'Load Test Results'
      condition: always()

# Pipeline notifications
resources:
  webhooks:
  - webhook: slack-notification
    connection: slack-buildaq
    filters:
    - path: stages
      value: DeployProduction
    - path: result
      value: failed